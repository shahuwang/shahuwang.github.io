## Rust 的指针类型

Rust有N多种指针类型，这复杂度，比C++都要高，也真是醉了。实际上，Rust为了实现不用GC又不用手动管理内存，在语法很多地方都做得很不优雅，甚至复杂度颇高。这篇文章不错：[Rust官方指南摘抄（四）指针][1]

Rust 的指针分别如下：

 1. &T， 称为引用，允许一个或者多个需求者读取 T
 2. &mut T， 可变引用，允许仅一个需求者读写 T，就是说 &mut T 之后，就不能再 &T 或者 &mut T 了。 这个其实很好理解了，因为被可变借出去了，对方不知道会对 T 做什么修改，如果还有另一个需求者在读或者写 T 的话，就不合法了。
 3. Box<T>, Box，这个Box好像到现在还不是很稳定，处于试验状态的样子。这是把数据的内存分配放到堆上了，被 box 之后，这个 T 就只能有一个需求者（或者称持有者），就是说 :

     `let x = Box::new(5i);
        let y = x;
        *x;
    `
这样子是非法的，一旦 box 的数据被借出去了，其持有者就变了。另外，box 的数据还有一个好处，其会在离开 scope 的时候自动清理掉。

 4. Rc<T>, "arr cee"指针， 堆分配一个可多人读取的 T
 5. Arc<T>, Arc指针，同上，但是线程间共享是安全的
 6. *const T , Raw 指针， 不安全读访问 T
 7. *mut T , 可变 raw 指针， 不安全读写访问 T

因为对后面四种指针很不熟悉，所以这里需要讲一下（我写博客主要是给自己看的，用于整理自己的思路）。

使用Box封装的对象，只能被一个所有者拥有，但是有时候我们需要将存在堆上的对象，分配多个使用者（只读，可改必然都只能是一个使用者），这时候Box就做不到了。

为了解决这个问题，可以使用 Rc<T>, 当然，它是不可改的，它采取引用计数的方式，每被分配一次，计数加1；每销毁了一次引用，计数减1； 在计数为0的时候自动销毁，或者在离开scope的时候也自动销毁。

同时还提供了一个Weak指针类型，不过现在还不是稳定状态。Python也有类型的东西。

具体内容可看 [std::rc][2]

Arc 指针提供了线程安全的保证，不过目前我对线程安全并不了解，不多写了。

raw 指针，其实挺像 c/c++ 的指针的，就是在你需要突破 Rust 的安全性限制写一些代码的时候用到的。当然，你写的函数给其他人用还依旧必须是符合 Rust 的安全要求的。
目前 raw 指针有几个要求是要记住的：

 - 不保证指向合法的地址，不保证不为null
 - 不会自动清理内存，需要手动清理
 - 不移交ownership
 - 没有Lifetime
 - have no guarantees about aliasing or mutability other than mutation not being allowed directly through a *const T. 这句没怎么搞懂

  [1]: http://blog.yikuyiku.com/?p=4485
  [2]: https://doc.rust-lang.org/std/rc/
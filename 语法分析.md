## 语法分析
----
在词法分析完成之后，就是语法分析。语法分析器的任务是判断单词流表示的输入程序在程序设计语言中是否是一个有效的句子，构造和推导出一个语法结构，将各个单词适配到源程序设计语言的语法模型中，最后构造成一个完整的具体模型（一般是语法树或者抽象语法树等层次化的数据结构），供后面的处理使用。

要能够对语言进行分析，首先语言就得有语法规则。对于程序设计语言构造的语法，可以用上下文无关文法和BNF（巴斯科-瑙尔范式）表示法来描述。巴斯科范式主要用来展示上下文无关文法的推导过程的。

上下文无关文法是一个比较庞大的类，一般做编译器的时候，只会用到其中的几种，LR(1) 和 LL(1)是最常用的两种。如下图,RG 表示正则文法，LR是比较大的一个子集，LL又是LR的子集。：

![enter image description here]( http://d.hiphotos.bdimg.com/album/s=550;q=90;c=xiangce,100,100/sign=bd132ff4f4246b607f0eb271dbc36b71/6a63f6246b600c33845eaf6f184c510fd9f9a175.jpg?referer=ae2e1d15b0b7d0a222de31ad0f2b&x=.jpg)

LR(1)语法可以通过从左至右的线性扫描自底向上进行语法分析，任何时候都只需从当前输入符号前瞻最多一个单词。LL(1)则是LR(1)的一个子集，通过从左向右进行扫描自顶向下进行语法分析，只需前瞻一个单词。利用手工编码的递归下降语法分析器或生成的LL(1)语法分析器可以解析LL（1）语法。正则文法一般用在词法分析里。几乎所有的程序设计语言结构都可以用LR（1）形式表达，通常也可以用LL（1）形式表达。因而，大多数的编译器使用的快速语法分析算法，都是基于这两种上下文无关文法的受限类别。

通过上面的解释，你大概也注意到，LR(1)和LL（1）这两个数字1表示的是前瞻多少个单词的意思，所以其实还有LR（4）之类的文法规则的。两个文法的第一个L都是表示from left to right, 而R则表示Right most，即最右推导，第二个L表示Left most，即最左推导。最左和最右推导后面会慢慢道来。

处理文法的语法分析器大体上可以分成三种类型，通用的，自底向上的和自顶向下的。像Cocke-Younger-Kasami算法和 Earley 算法这样的通用语法分析方法可以对任意文法进行语法分析，但是效率太低，不能用于编译器产品。所以目前使用的都是自顶向下或者自底向上方式。

自顶向下语法分析器是从根开始构建语法树，并使树向叶子的方向增长，在每一步自顶向下语法分析器都在树的下边缘选择一个表示某个非终结符的结点，用一个子树来扩展该结点；子树表示了重写该非终结符时所用产生式的右侧部分。

自底向上语法分析器从叶子节点开始构建语法树，并使树向根的方向增长。在每一步，自底向上语法分析器都在语法分析树的上边缘处识别出一个连续的子串，该子串与某个产生式的右侧匹配，接下来构建一个结点表示该产生式的左侧，并将其连接到树中。

看完这些是否觉得已经晕头转向了呢？关于终结符，非终结符，上下文无法文法等概念，需要先看我的这篇博客：[《什么是文法》](http://www.shahuwang.com/2013/12/31/%e4%bb%80%e4%b9%88%e6%98%af%e6%96%87%e6%b3%95.html) 。下面我会讲讲什么事最右推导，什么事最左推导。看完上面的内容，大概就知道，LR（1）对应着自底向上，LL（1）则对应着自顶向下。

为了讲解上下文无关文法，最左推导，最右推导，语法树的构建，我这里主要参考《自动机理论、语言和计算导论》，以一个例子进行讲解。

我们构建一个CFG（上下文无关文法），形式化表示为$G = (\{E, I\}, T, P, E)$ 。CFG的形式化表示一般是这样的：$G = (V, T, P, S)$, 其中，V是变元的集合，就是$\{E,I\}$这个集合啦。$T$是终结符的结合，$P$是产生式的集合，$S$代表初始符号，所以我们设计的CFG里的E，既是变元（代表表达式），也是初始符号（一般都如此）。我们的CFG只有六个符号,也就是终结符，+和\*代表加法和乘法，字母有a和b，数字有0和1，每个标识符都必须由a或者b开头，其后跟着{a,b,0,1}\*中的串,类似于这样：

> $(a+b)*(a0+b10a)$


上面所展示的，就是我们的文法所可以表达的一个表达式。该CFG的产生式如下：

+ $E\Rightarrow I$
+ $E\Rightarrow E+E$
+ $E\Rightarrow E*E$
+ $E\Rightarrow (E)$
+ $I\Rightarrow a$
+ $I\Rightarrow b$
+ $I\Rightarrow Ia$
+ $I\Rightarrow Ib$
+ $I\Rightarrow I0$
+ $I\Rightarrow I1$

现在我们要判断$a*(a+b00)$这个串是否属于这个CFG，所以要进行推导，最左推导如下：

> $E\Rightarrow E*E$
> $\quad  \Rightarrow I*E$
> $\quad \Rightarrow a*E$
> $\quad \Rightarrow a*(E)$
> $\quad \Rightarrow a*(E+E)$
> $\quad \Rightarrow a*(I+E)$
> $\quad \Rightarrow a*(a+E)$
> $\quad \Rightarrow a*(a+I)$
> $\quad \Rightarrow a*(a+I0)$
> $\quad \Rightarrow a*(a+I00)$
> $\quad \Rightarrow a*(a+b00)$

通过上面的推导，我们知道$a*(a+b00)$这个串是属于我们这个CFG的，上面就是最左推导，下面是最右推导，两个出来之后一对比，就知道两者什么意思了。

>$E\Rightarrow E*E$
>$\quad \Rightarrow E*(E)$
>$\quad \Rightarrow E*(E+E)$
>$\quad \Rightarrow E*(E+I)$
>$\quad \Rightarrow E*(E+I0)$
>$\quad \Rightarrow E*(E+I00)$
>$\quad \Rightarrow E*(E+b00)$
>$\quad \Rightarrow E*(I+b00)$
>$\quad \Rightarrow E*(a+b00)$
>$\quad \Rightarrow I*(a+b00)$
>$\quad \Rightarrow a*(a+b00)$

通过最右推导，也同样能够推导出$a*(a+b00)$

通过上面的对比，很容易看出，最左推导，是从产生式右边的最左边开始，把它从表达式逐步变成终结符。而最右推导则是从产生式右边的最右边开始，把它从表达式逐步变成终结符。
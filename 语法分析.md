## 语法分析
----
在词法分析完成之后，就是语法分析。语法分析器的任务是判断单词流表示的输入程序在程序设计语言中是否是一个有效的句子，构造和推导出一个语法结构，将各个单词适配到源程序设计语言的语法模型中，最后构造成一个完整的具体模型（一般是语法树或者抽象语法树等层次化的数据结构），供后面的处理使用。

要能够对语言进行分析，首先语言就得有语法规则。对于程序设计语言构造的语法，可以用上下文无关文法和BNF（巴斯科-瑙尔范式）表示法来描述。巴斯科范式主要用来展示上下文无关文法的推导过程的。

上下文无关文法是一个比较庞大的类，一般做编译器的时候，只会用到其中的几种，LR(1) 和 LL(1)是最常用的两种。如下图,RG 表示正则文法，LR是比较大的一个子集，LL又是LR的子集。：

![enter image description here]( http://d.hiphotos.bdimg.com/album/s=550;q=90;c=xiangce,100,100/sign=bd132ff4f4246b607f0eb271dbc36b71/6a63f6246b600c33845eaf6f184c510fd9f9a175.jpg?referer=ae2e1d15b0b7d0a222de31ad0f2b&x=.jpg)

LR(1)语法可以通过从左至右的线性扫描自底向上进行语法分析，任何时候都只需从当前输入符号前瞻最多一个单词。LL(1)则是LR(1)的一个子集，通过从左向右进行扫描自顶向下进行语法分析，只需前瞻一个单词。利用手工编码的递归下降语法分析器或生成的LL(1)语法分析器可以解析LL（1）语法。正则文法一般用在词法分析里。几乎所有的程序设计语言结构都可以用LR（1）形式表达，通常也可以用LL（1）形式表达。因而，大多数的编译器使用的快速语法分析算法，都是基于这两种上下文无关文法的受限类别。

通过上面的解释，你大概也注意到，LR(1)和LL（1）这两个数字1表示的是前瞻多少个单词的意思，所以其实还有LR（4）之类的文法规则的。两个文法的第一个L都是表示from left to right, 而R则表示Right most，即最右推导，第二个L表示Left most，即最左推导。最左和最右推导后面会慢慢道来。

处理文法的语法分析器大体上可以分成三种类型，通用的，自底向上的和自顶向下的。像Cocke-Younger-Kasami算法和 Earley 算法这样的通用语法分析方法可以对任意文法进行语法分析，但是效率太低，不能用于编译器产品。所以目前使用的都是自顶向下或者自底向上方式。

自顶向下语法分析器是从根开始构建语法树，并使树向叶子的方向增长，在每一步自顶向下语法分析器都在树的下边缘选择一个表示某个非终结符的结点，用一个子树来扩展该结点；子树表示了重写该非终结符时所用产生式的右侧部分。

自底向上语法分析器从叶子节点开始构建语法树，并使树向根的方向增长。在每一步，自底向上语法分析器都在语法分析树的上边缘处识别出一个连续的子串，该子串与某个产生式的右侧匹配，接下来构建一个结点表示该产生式的左侧，并将其连接到树中。

看完这些是否觉得已经晕头转向了呢？关于终结符，非终结符，上下文无法文法等概念，需要先看我的这篇博客：[《什么是文法》](http://www.shahuwang.com/2013/12/31/%e4%bb%80%e4%b9%88%e6%98%af%e6%96%87%e6%b3%95.html) 。下面我会讲讲什么事最右推导，什么事最左推导。看完上面的内容，大概就知道，LR（1）对应着自底向上，LL（1）则对应着自顶向下。

为了讲解上下文无关文法，最左推导，最右推导，语法树的构建，我这里主要参考《自动机理论、语言和计算导论》，以一个例子进行讲解。

我们构建一个CFG（上下文无关文法），形式化表示为$G = (\{E, I\}, T, P, E)$ 。CFG的形式化表示一般是这样的：$G = (V, T, P, S)$, 其中，V是变元的集合，就是$\{E,I\}$这个集合啦。$T$是终结符的结合，$P$是产生式的集合，$S$代表初始符号，所以我们设计的CFG里的E，既是变元（代表表达式），也是初始符号（一般都如此）。我们的CFG只有六个符号,也就是终结符，+和\*代表加法和乘法，字母有a和b，数字有0和1，每个标识符都必须由a或者b开头，其后跟着{a,b,0,1}\*中的串,类似于这样：

> $(a+b)*(a0+b10a)$


上面所展示的，就是我们的文法所可以表达的一个表达式。该CFG的产生式如下：

+ $E\Rightarrow I$
+ $E\Rightarrow E+E$
+ $E\Rightarrow E*E$
+ $E\Rightarrow (E)$
+ $I\Rightarrow a$
+ $I\Rightarrow b$
+ $I\Rightarrow Ia$
+ $I\Rightarrow Ib$
+ $I\Rightarrow I0$
+ $I\Rightarrow I1$

现在我们要判断$a*(a+b00)$这个串是否属于这个CFG，所以要进行推导，最左推导如下：

> + $E\Rightarrow E*E$    
> + $\quad \Rightarrow a*E$  
> + $\quad \Rightarrow a*(E)$  
> + $\quad \Rightarrow a*(E+E)$  
> + $\quad \Rightarrow a*(I+E)$  
> + $\quad \Rightarrow a*(a+E)$  
> + $\quad \Rightarrow a*(a+I)$  
> + $\quad \Rightarrow a*(a+I0)$  
> + $\quad \Rightarrow a*(a+I00)$   
> + $\quad \Rightarrow a*(a+b00)$  

通过上面的推导，我们知道$a*(a+b00)$这个串是属于我们这个CFG的，上面就是最左推导，下面是最右推导，两个出来之后一对比，就知道两者什么意思了。

>+ $E\Rightarrow E*E$  
>+ $\quad \Rightarrow E*(E)$  
>+ $\quad \Rightarrow E*(E+E)$  
>+ $\quad \Rightarrow E*(E+I)$  
>+ $\quad \Rightarrow E*(E+I0)$  
>+ $\quad \Rightarrow E*(E+I00)$  
>+ $\quad \Rightarrow E*(E+b00)$  
>+ $\quad \Rightarrow E*(I+b00)$  
>+ $\quad \Rightarrow E*(a+b00)$  
>+ $\quad \Rightarrow I*(a+b00)$  
>+ $\quad \Rightarrow a*(a+b00)$  

通过最右推导，也同样能够推导出$a*(a+b00)$

通过上面的对比，很容易看出，最左推导，是从产生式右边的最左边开始，把它从表达式逐步变成终结符。而最右推导则是从产生式右边的最右边开始，把它从表达式逐步变成终结符。

通过上面的推导过程，现在已经可以根据文法推导判断出一个串是否属于文法了。不过在实践中，一般使用语法树，语法树的好处一个是很直观，另一个则是我们可以通过语法树，递归构建语法分析器，因为树的特点就是递归。

满足下列条件的树称为文法G的语法树：
>(1)每个结点用G的一个终结符或非终结符标记;
(2)根结点用文法开始符S标记;
(3)内部结点一定是非终结符,若某内部结点A有n个分支, 且其所有子结点从左至右依次标记为x1, x2, …,xn,则A→x1x2…xn一定是G的一条产生式;
(4)若某结点标记为ε,则它必为叶结点且是其父结点的唯一子结点。

如下图就是上面推导过程对应的语法树：

![语法树](http://a.hiphotos.bdimg.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=9b073e418f1001e94a3c140a88350ad1/7dd98d1001e9390119f4fa9679ec54e737d196a7.jpg?referer=719f4bbbdf54564ebc72d009d27d&x=.jpg)

上面这棵语法树其实在构建的过程中省去了很多的细节，最重要的一点就是程序是如何在可能产生的分支上做出选择的？譬如$E$可以推出$E+E$, 也可以推出$E+I$,程序是如何在这两者进行选择的呢？一般的话，是会有一个预测分析器的，其可以通过向前看K个单词，来预测该推导的产生式。LL(1)就是向前看一个单词就可以做出判断了。这个下面开始详细的说。

自顶向下语法分析可以被看作是为输入串构造语法分析树的问题，它从语法分析树的根结点开始，按照深度优先的先根次序创建这棵语法树的各个结点。当然，同时其也是最左推导的过程。在这个过程的每个结点上，都需要考虑一个部分完成的语法分析树，在树的下边缘选择一个非终结符，选定某个适用于该非终结符的产生式，用于产生式右侧相对应的子树来扩展该结点。这个过程会一直持续下去，直到：  

+ 语法分析树的下边缘只包含终结符，且输入流已经耗尽
+ 或者部分完成的语法分析树的下边缘各结点，与输入流存在着明确的不匹配

对于第一种情况，语法分析器是成功的。第二种情况，有两种可能性，一个是语法分析器在此前的分析过程中选择了错误的产生式，在这种情况下可以进行回溯，导向正确的路径。又或者，输入的符号串是错误的，那么回溯就将失败，此时需要向用户报告错误所在。

自顶向下的语法分析器可以高效进行的一个关键点是：上下文无关文法的很大一个子集不进行回溯即可完成语法分析。通过一些变换，就可以将任意的语法转化为适当的形式，使之适合于进行无回溯的自顶向下语法分析。构造自顶向下语法分析器主要有两种技术，一个是递归下降语法分析，一个是LL(1)语法分析。关于这两个概念，我发现很多书籍讲述的都很矛盾，理不太清。我个人认为，LL(1)首先是上下文无关文法的一个子集，这种文法的特点可以用来进行递归下降语法分析器的构建。所以我们并不需要把这两者割裂开来看（文章写到后面才发觉这里写的不对回来修改了）。不过，除了递归下降，还有基于表的LL(1)语法分析器构建方式。

下面先讲讲是通过那些方法对文法进行转换，使得自顶向下的分析可以高效正确进行。

有一些文法设计出来后，会出现二义性问题，即同一个串，可以构造出两种语法树。有些时候，二义性是精心添加的，这样有一定的好处。有时候是文法设计的问题。但是，出现二义性之后，都需要通过一些方法来排除掉不需要的那棵语法树。二义性消除没有什么规定的方法，因为出现二义性的情况很多，并没有统一的规律。目前所见的有运算符优先级设定;结合方式设定,如规定左结合；还有的就是在语法上进行强制，譬如说出现了if和then，那么就必须使用else结束，否则就是语法错误。

对于文法的歧义性来说，实际上想要首先判断一个CFG是不是歧义的，也不存在一个算法能够实现。所以，要想用一个算法来消除歧义，就更不可能了。而即使文法是无歧义的，推导不可能不少唯一的，不过最左推导和最右推导一定是唯一的。

左递归消除是一种比较重要的转换。
> $如果一个文法中有一股非终结符A，使得对某个串\alpha存在一个推导A\stackrel + {\Rightarrow}A\alpha，那么其就是左递归的。$  
$注意，\stackrel + {\Rightarrow} 表示一步或者多步推导$

关于左递归消除的方法，主要有消除直接左递归，和消除间接左递归，具体方法可以看这篇文章：[编译原理：消除左递归](http://blog.sina.com.cn/s/blog_687911280100nc8t.html)

提供效率的另一种方式是提取公因子，这也是预测分析的一种方式。譬如对于文法$A\Rightarrow \alpha\beta_1|\alpha\beta_2$,(注意，| 表示或的意思，就是可以推出两者，任选一个），当读取到字符$\alpha$的时候，此时分析器无法判断该往那边走。而如果我们把文法提取出公因子，变成这样：$A\Rightarrow \alpha A^`, A`\Rightarrow \beta_1|\beta_2$, 此时读入$\alpha$后面的一个单词，我们就知道是该到$\beta_1$还是到$\beta_2$去了。

在进入递归下降语法分析器内容之前，首先需要了解两个概念，一个是First集，一个是Follow集。关于这个概念，我觉得这篇文章讲解得比较好，[编译原理：求First集与Follow集的方法](http://www.kaisir.com/2011/06/compiler-theory-find-first-set-of-sets-and-follow.html), 看完这篇文章应该就大致明白了。通过一些计算First集合和Follow集合的算法，就能够实现自动预测，从而自动生成递归下降语法分析器。

关于递归下降语法分析，可以看这篇文章：[《自己动手开发编译器（七）递归下降的语法分析器》](http://www.cnblogs.com/Ninputer/archive/2011/06/21/2085527.html) , 由于其代码比较多，我这里主要摘抄核心部分，递归下降语法分析的步骤：

>+ 使用一个索引来记录当前扫描的位置。
+  为每个非终结符编写一个方法。
+  如果一个非终结符有超过一个的产生式，则在这个方法中对采用哪个产生式进行分支预测。
+  处理单一产生式时，遇到正确终结符则将第一步创建的扫描索引位置向前移动；如遇到非终结符则调用第二步中创建的相应方法。
+  如果需要产生解析的结果（比如本例中的二叉树），在方法返回之前将它构造出来。

支持递归下降分析的文法，一般称为LL(K)文法，LL(1)是最常用的一种，其要求一不能有左递归，而不能有左公因式，所以要进行左递归消除和公因式提取。进行预测的方法一般都是先向前看K个字符，然后判断该往哪个分支走。

除了递归下降，还有一种方法就是表驱动的语法分析，这里就不细说了。

上面的部分，已经把自顶向下语法分析的主要内容讲解完毕了。说实在的，写的真的很累人啊，写了四个晚上了。最近在看Redis的源代码，其实我主要是想通过看源代码学习C语言，感觉进展不错。写这篇博客写到这里已经有点儿累了，所以自底向上语法分析的部分将放到下篇博客去写，不过估计得一两个星期之后了。